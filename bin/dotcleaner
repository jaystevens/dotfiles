#!/usr/bin/env python

import os
import shutil
import sys
import argparse
import traceback

try:
    import scandir
    scanner = scandir.walk
except:
    scanner = os.walk
    if sys.version_info.major == 2:
        print('python2 built-in os.walk is very slow\nconsider installing scandir module or upgrading to python3.5+')


def dotcleaner(folder_path, dry_run=False):
    files_to_delete = []
    dirs_to_delete = []

    if folder_path is None:
        print('please provide as path')
        return

    folder_path = os.path.realpath(folder_path)
    folder_path = os.path.normpath(folder_path)

    if not os.path.exists(folder_path):
        print('path does not exist: {}'.format(folder_path))
        return

    try:
        for (root, dirs, files) in scanner(folder_path):
            for f_name in files:
                #f_name_lower = f_name.lower()
                if f_name == '.DS_Store':
                    files_to_delete.append(os.path.join(root, f_name))
                elif f_name == '._.DS_Store':
                    files_to_delete.append(os.path.join(root, f_name))
                elif f_name.startswith('._'):
                    files_to_delete.append(os.path.join(root, f_name))
                elif f_name == 'Thumbs.db':
                    files_to_delete.append(os.path.join(root, f_name))

            for d_name in dirs:
                if d_name == '@eaDir':
                    dirs_to_delete.append(os.path.join(root, d_name))

    except (OSError):
        print('error accessing directory')
        sys.exit()

    files_to_delete = sorted(files_to_delete, key=lambda s: s.lower())
    dirs_to_delete = sorted(dirs_to_delete, key=lambda s: s.lower())

    txt_prefix = ''
    if dry_run is True:
        txt_prefix = 'would remove'
    else:
        txt_prefix = 'removing'

    for item in files_to_delete:
        try:
            print('{}: {}'.format(txt_prefix, item))
            if dry_run is False:
                os.remove(item)
        except:
            print('error removing: {}'.format(item))
            #traceback.print_exc()

    for item in dirs_to_delete:
        try:
            print('{} dir: {}'.format(txt_prefix, item))
            if dry_run is False:
                shutil.rmtree(item)
        except:
            print('error removing: {}'.format(item))
            #traceback.print_exc()


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='dotcleaner', epilog='deletes .DS_Store and ._ files, also removes @eaDir folders')
    parser.add_argument('-p', '--path', dest='path', default=None, help='path to clean', required=True)
    parser.add_argument('-n', '--dry-run', dest='dryrun', default=False, action='store_true', help='dry run (do not remove files)')

    args = parser.parse_args()
    try:
        dotcleaner(args.path, args.dryrun)
    except KeyboardInterrupt:
        print('\n' + 'Byte')
        sys.exit(0)
    except SystemExit:
        pass
    except:
        traceback.print_exc()
